chapter_13: 拷贝构造函数，拷贝赋值运算符
chapter_13 NOTICE:
            
            /* 拷贝构造函数 */
            1. class_name( const class_name&) 注意是引用型
            2. class a=b; 触发 非引用形参 触发 返回非引用类型 触发， 向容器push_back对象时也会触发
               所以说容器内的对象不会影响原来用来赋值的那个对象；但是emplace不一样
            3. 使用默认的合成构造函数，如果类内有指针成员，会造成两个实例内成员指向同一个内存（潜复制），
               调用析构函数时会清空两次内存引发异常
            4. 合成的会将非static成员拷贝在正在创建的对象中
            /* 拷贝构造函数 */
            1. class_name& operator=(const class_name&)
            2. a=b时触发（已经初始化后使用赋值运算符）
            3. 赋值运算符返回左侧运算对象的引用


            /*析构函数*/
            1. 成员是指针，析构函数不会delete该指针所指向的对象
            2. 触发条件： 离开作用域、delete手动销毁、容器被销毁时自动删除其元素、临时对象
            3. 对象的引用、指针离开作用域时不会触发析构函数
